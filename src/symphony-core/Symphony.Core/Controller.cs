using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;
using System.Threading;
using System.Collections.Concurrent;
using log4net;

namespace Symphony.Core
{
    /// <summary>
    /// Serves as the "core of the Core": a clearinghouse for epoch
    /// descriptions, which are made available for IExternalDevice
    /// instances to pull "outgoing" stimulus commands, and capture
    /// the IExternalDevice's "incoming" responses to those stimulus
    /// commands. The Controller manages the bookkeeping of providing
    /// appropriate stimuli for each device and assigning incoming responses
    /// to the appropriate Epoch's Response.
    /// 
    /// <para>The terms "outgoing" and "incoming" can be confusing;
    /// these are from the perspective of the PC driving the experiment
    /// rig. Commands are "outgoing" from the PC to the sensors and
    /// apparatus, and the data generated by the hardware rig are "incoming" 
    /// to the PC.</para>
    /// 
    /// <para>In truth, "outgoing" doesn't imply that the Controller
    /// "pushes" the commands out to the device--the device will pull them
    /// from the Controller, so the Controller only needs to maintain a
    /// stream of them for the device to pull when ready. And, to complete
    /// the role-reversal, the device "pushes" the results to the Controller
    /// when the results are coming back from the device.</para>
    /// 
    /// </summary>
    public class Controller : ITimelineProducer
    {
        private readonly object _eventLock = new Object();

        /// <summary>
        /// Construct a Controller object and input/ouput pipeline from the configuration file at
        /// the given path.
        /// </summary>
        /// <param name="configurationPath">Configuration file path</param>
        /// <returns>Configured Controller and input/output pipelines</returns>
        public static Controller FromConfiguration(string configurationPath)
        {
            return new Parser().ParseConfiguration(configurationPath);
        }

        /// <summary>
        /// Construct a new Controller with no DAQ bridge and using the system (CPU) clock.
        /// </summary>
        public Controller() : this(null, new SystemClock())
        {
        }

        /// <summary>
        /// Construct a Controller with Clock and DAQ Bridge.
        /// </summary>
        /// <param name="daq">DAQ bridge to use as the pipeline endpoint</param>
        /// <param name="clock">Canonical clock</param>
        public Controller(IDAQController daq, IClock clock)
        {
            Clock = clock;
            DAQController = daq;

            Init();
        }

        private void Init()
        {
            Devices = new HashSet<IExternalDevice>();
            EpochQueue = new ConcurrentQueue<Epoch>();
            OutputStreams = new ConcurrentDictionary<IExternalDevice, SequenceOutputStream>();
            InputStreams = new ConcurrentDictionary<IExternalDevice, SequenceInputStream>();
            BackgroundStreams = new Dictionary<IExternalDevice, IOutputStream>();
            CompletedEpochTasks = new List<Task>();
            PersistEpochTasks = new List<Task>();
            Configuration = new Dictionary<string, object>();
            CompletedEpochTaskScheduler = new SerialTaskScheduler();
            PersistEpochTaskScheduler = new SerialTaskScheduler();
        }

        private class SerialTaskScheduler : LimitedConcurrencyLevelTaskScheduler
        {
            public SerialTaskScheduler()
                : base(1)
            {   
            }
        }

        /// <summary>
        /// A task scheduler for tasks firing the CompletedEpoch event.
        /// </summary>
        private SerialTaskScheduler CompletedEpochTaskScheduler { get; set; }

        /// <summary>
        /// A list of incomplete tasks firing the CompletedEpoch event.
        /// </summary>
        private IList<Task> CompletedEpochTasks { get; set; } 

        /// <summary>
        /// Blocks for completion of all asynchronous task firing the CompletedEpoch event. 
        /// </summary>
        public void WaitForCompletedEpochTasks()
        {
            Task.WaitAll(CompletedEpochTasks.ToArray());
        }

        /// <summary>
        /// A task scheduler for tasks persisting completed Epochs.
        /// </summary>
        private SerialTaskScheduler PersistEpochTaskScheduler { get; set; }

        /// <summary>
        /// A list of incomplete tasks persisting completed Epochs. 
        /// </summary>
        private IList<Task> PersistEpochTasks { get; set; }

        /// <summary>
        /// The canonical clock for the experimental timeline
        /// </summary>
        public IClock Clock { get; set; }

        /// <summary>
        /// Parameters of this controller's configuration.
        /// </summary>
        public IDictionary<string, object> Configuration { get; private set; }

        /// <summary>
        /// A Controller has 0..n Devices connected to it. It is callers'
        /// responsibility to ensure the ExternalDevice refers back to this
        /// Controller. (Use the Validate() method to ensure all the
        /// connections are wired up correctly.). You should use
        /// AddDevice to add a device to this controller rather than manipulating
        /// Devices directly.
        /// </summary>
        /// 
        /// <see cref="AddDevice"/>
        public ISet<IExternalDevice> Devices { get; private set; }

        /// <summary>
        /// The DAQ hardware controller for this Controller's configuration.
        /// </summary>
        public IDAQController DAQController { get; set; }

        /// <summary>
        /// Enumerable collection of available IHardwareControllers in this Controller's
        /// input/ouput piplines. IHardwareControllers may be DAQ Controllers, video output
        /// controllers, etc.
        /// </summary>
        public IEnumerable<IHardwareController> HardwareControllers
        {
            get
            {
                return new IHardwareController[] { DAQController };
            }
        }

        /// <summary>
        /// Flag indicating whether the Controller is running.
        /// </summary>
        public bool IsRunning { get; protected set; }

        /// <summary>
        /// Add an ExternalDevice to the Controller; take care of performing
        /// whatever wiring up between the Controller and the ExternalDevice
        /// needs to be done, as well.
        /// </summary>
        /// <param name="dev">The ExternalDevice to wire up</param>
        /// <exception cref="InvalidOperationException">This controller already has a device with the same name.</exception>
        /// <returns>This instance, for fluent-style API calls</returns>
        public Controller AddDevice(IExternalDevice dev)
        {
            if (Devices.Any(d => d.Name == dev.Name))
                throw new InvalidOperationException("Device with name " + dev.Name + " already exists.");

            Devices.Add(dev);
            dev.Controller = this;
            return this;
        }

        /// <summary>
        /// Gets the device with given name connected to this controller. Because devices must be unique
        /// by name, there can be at most one device with the given name.
        /// </summary>
        /// <param name="name">Device name</param>
        /// <returns>ExternalDevice instance with the given name or null if none exists</returns>
        /// <see cref="AddDevice"/>
        public IExternalDevice GetDevice(string name)
        {
            return Devices.Where(d => d.Name == name).DefaultIfEmpty(null).First();
        }
        
        // Virtual for unit testing only.
        /// <summary>
        /// Double-check that all the pieces of the pipeline are wired up
        /// correctly--the ExternalDevices all point to this controller,
        /// and so on. Recursively validates on down the line, so any
        /// ExternalDevices connected here will have their Validate() method
        /// called as part of this, and so on.
        /// </summary>
        /// <returns>A monad indicating validation (as a bool) or the error message (if cast to a string)</returns>
        public virtual Maybe<string> Validate()
        {
            if (Clock == null)
                return Maybe<string>.No("Controller.Clock must not be null.");

            if (DAQController == null)
                return Maybe<string>.No("Controller.DAQController must not be null.");

            var daqVal = DAQController.Validate();
            if (daqVal != true)
                return daqVal;

            // I think we're OK just adding all necessary devices the client failed to add
            // instead of complaining and forcing them to do it
            foreach (var stream in DAQController.OutputStreams.Where(s => s.Active))
            {
                if (!Devices.Contains(stream.Device))
                {
                    AddDevice(stream.Device);
                }
            }

            foreach (var stream in DAQController.InputStreams.Where(s => s.Active))
            {
                foreach (var device in stream.Devices.Where(d => !Devices.Contains(d)))
                {
                    AddDevice(device);
                }
            }

            foreach (ExternalDeviceBase ed in Devices)
            {
                if (ed.Controller != this)
                {
                    // We can either bail out (return false), or fix it
                    // I think we're OK to just fix it
                    ed.Controller = this;
                }

                Maybe<string> edVal = ed.Validate();
                if (edVal != true)
                {
                    // Beginning to think there's a better way than just
                    // returning false--if we fail, we probably should have
                    // some kind of idea of what failed
                    return Maybe<string>.No("External device " +
                        ed.ToString() + " failed to validate: " +
                        edVal.Item2);
                }

                if (ed.OutputStreams.Any() && (!BackgroundStreams.ContainsKey(ed) || BackgroundStreams[ed].Duration))
                {
                    return Maybe<string>.No(
                        ed.Name + " must have an associated background stream of indefinite duration.");
                }
            }

            return Maybe<string>.Yes();
        }
        
        /// <summary>
        /// This controller started.
        /// </summary>
        public event EventHandler<TimeStampedEventArgs> Started;

        /// <summary>
        /// This controller received input data.
        /// </summary>
        public event EventHandler<TimeStampedDeviceDataEventArgs> ReceivedInputData;

        /// <summary>
        /// This controller pulled output data from an output stream.
        /// </summary>
        public event EventHandler<TimeStampedDeviceOutputStreamEventArgs> PulledOutputData;

        /// <summary>
        /// This controller pushed input data to an input stream.
        /// </summary>
        public event EventHandler<TimeStampedDeviceInputStreamEventArgs> PushedInputData;

        /// <summary>
        /// This controller persisted a completed Epoch.
        /// </summary>
        public event EventHandler<TimeStampedEpochEventArgs> SavedEpoch;

        /// <summary>
        /// This controller completed an Epoch.
        /// </summary>
        public event EventHandler<TimeStampedEpochEventArgs> CompletedEpoch;

        /// <summary>
        /// This controller discarded a running epoch due to an exception in the output or input pipelines.
        /// </summary>
        public event EventHandler<TimeStampedEpochEventArgs> DiscardedEpoch;

        /// <summary>
        /// This controller received a RequestPause() request.
        /// </summary>
        public event EventHandler<TimeStampedEventArgs> RequestedPause;

        /// <summary>
        /// This controller received a RequestStop() request.
        /// </summary>
        public event EventHandler<TimeStampedEventArgs> RequestedStop;

        /// <summary>
        /// This controller stopped.
        /// </summary>
        public event EventHandler<TimeStampedEventArgs> Stopped;

        private void OnStarted()
        {
            FireEvent(Started);
        }

        private void OnReceivedInputData(IExternalDevice device, IIOData data)
        {
            FireEvent(ReceivedInputData, device, data);
        }

        private void OnPulledOutputData(IExternalDevice device, IOutputStream stream)
        {
            FireEvent(PulledOutputData, device, stream);
        }

        private void OnPushedInputData(IExternalDevice device, IInputStream stream)
        {
            FireEvent(PushedInputData, device, stream);
        }

        private void OnSavedEpoch(Epoch epoch)
        {
            FireEvent(SavedEpoch, epoch);
        }

        private void OnCompletedEpoch(Epoch epoch)
        {
            FireEvent(CompletedEpoch, epoch);
        }

        private void OnDiscardedEpoch(Epoch epoch)
        {
            FireEvent(DiscardedEpoch, epoch);
        }

        private void OnRequestedPause()
        {
            FireEvent(RequestedPause);
        }

        private void OnRequestedStop()
        {
            FireEvent(RequestedStop);
        }

        private void OnStopped()
        {
            FireEvent(Stopped);
        }

        private void FireEvent(EventHandler<TimeStampedEpochEventArgs> evt, Epoch epoch)
        {
            FireEvent(evt, new TimeStampedEpochEventArgs(Clock, epoch));
        }

        private void FireEvent(EventHandler<TimeStampedDeviceDataEventArgs> evt, IExternalDevice device, IIOData data)
        {
            FireEvent(evt, new TimeStampedDeviceDataEventArgs(Clock, device, data));
        }
        
        private void FireEvent(EventHandler<TimeStampedDeviceOutputStreamEventArgs> evt, IExternalDevice device,
                               IOutputStream stream)
        {
            FireEvent(evt, new TimeStampedDeviceOutputStreamEventArgs(Clock, device, stream));
        }

        private void FireEvent(EventHandler<TimeStampedDeviceInputStreamEventArgs> evt, IExternalDevice device,
                               IInputStream stream)
        {
            FireEvent(evt, new TimeStampedDeviceInputStreamEventArgs(Clock, device, stream));
        }

        private void FireEvent(EventHandler<TimeStampedEventArgs> evt)
        {
            FireEvent(evt, new TimeStampedEventArgs(Clock));
        }

        private void FireEvent<T>(EventHandler<T> evt, T args) where T : TimeStampedEventArgs
        {
            lock (_eventLock)
            {
                if (evt == null) 
                    return;
                
                try
                {
                    evt(this, args);
                }
                catch (Exception e)
                {
                    log.ErrorFormat("{0} threw an exception: {1}", evt.Method.Name, e);
                    throw;
                }
            }
        }
        
        /// <summary>
        /// Pulls IOutputData from the output stream for the given device. Result will have 
        /// a duration greater than or equal to the requested duration.
        /// </summary>
        /// <param name="device">ExternalDevice for this outputdata</param>
        /// <param name="duration">Duration of the data requested</param>
        /// <returns>Output data for the requested device of duration greater than or equal to
        /// the requested duration.</returns>
        public virtual IOutputData PullOutputData(IExternalDevice device, TimeSpan duration)
        {
            var outStream = OutputStreams[device];

            IOutputData outData = null;

            while (outData == null || outData.Duration < duration)
            {
                if (outStream.IsAtEnd)
                {
                    var msg = "Output stream exhausted for " + device.Name;
                    log.Error(msg);
                    throw new SymphonyControllerException(msg);
                }

                outData = outData == null
                    ? outStream.PullOutputData(duration)
                    : outData.Concat(outStream.PullOutputData(duration - outData.Duration));

                OnPulledOutputData(device, outStream);
            }

            return outData;
        }

        /// <summary>
        /// Pushes IInputData to the input stream for the given device.
        /// </summary>
        /// <param name="device">ExternalDevice providing the data</param>
        /// <param name="inData">Input data instance</param>
        public virtual void PushInputData(ExternalDeviceBase device, IInputData inData)
        {
            OnReceivedInputData(device, inData);

            var inStream = InputStreams[device];

            var unpushedInData = inData;

            while (unpushedInData.Duration > TimeSpan.Zero)
            {
                if (inStream.IsAtEnd)
                {
                    var msg = "Input stream exhausted for " + device.Name;
                    log.Error(msg);
                    throw new SymphonyControllerException(msg);
                }

                var dur = (bool)inStream.Duration 
                    ? inStream.Duration - inStream.Position 
                    : unpushedInData.Duration;

                var cons = unpushedInData.SplitData(dur);
                
                inStream.PushInputData(cons.Head);
                unpushedInData = cons.Rest;

                OnPushedInputData(device, inStream);
            }
        }

        /// <summary>
        /// The main queue of Epochs waiting to be buffered by this Controller.
        /// </summary>
        private ConcurrentQueue<Epoch> EpochQueue { get; set; }

        /// <summary>
        /// Add an Epoch to the Controller's Epoch queue. Epochs are presented in FIFO order from
        /// this queue when running. You can use RunEpoch to bypass this queue, presenting an Epoch
        /// immediately
        /// </summary>
        /// <param name="e">Epoch to add to the queue</param>
        /// <see cref="RunEpoch(Epoch, EpochPersistor)"/>
        public void EnqueueEpoch(Epoch e)
        {
            if (!ValidateEpoch(e))
                throw new ArgumentException(ValidateEpoch(e));

            EpochQueue.Enqueue(e);

            log.DebugFormat("Queued epoch: {0}", e.ProtocolID);
        }

        /// <summary>
        /// Removes all Epochs from the Epoch queue.
        /// </summary>
        public void ClearEpochQueue()
        {
            while (!EpochQueue.IsEmpty)
            {
                Epoch ignore;
                EpochQueue.TryDequeue(out ignore);
            }
        }

        // Protected virtual for unit testing only.
        protected virtual Maybe<string> ValidateEpoch(Epoch epoch)
        {
            if (epoch.IsIndefinite && epoch.Responses.Count > 0)
                return Maybe<string>.No("Indefinite Epochs cannot have responses.");

            if (epoch.Stimuli.Values.Any(s => ((bool)s.Duration) != ((bool)epoch.Duration) || ((TimeSpan)s.Duration).Ticks != ((TimeSpan)epoch.Duration).Ticks))
                return Maybe<string>.No("All Epoch stimuli must have equal duration.");

            foreach (var dev in Devices)
            {
                if (dev.OutputStreams.Any() && epoch.GetOutputStream(dev) == null)
                    return Maybe<string>.No("Epoch is missing a stimulus/background for device " + dev.Name);

                if (dev.OutputStreams.Any() && !Equals(dev.OutputSampleRate, epoch.GetOutputStream(dev).SampleRate))
                    return Maybe<string>.No("Epoch stimulus/background sample rate does not match sample rate for device " + dev.Name);
            }

            foreach (var dev in epoch.Stimuli.Keys)
            {
                if (!Devices.Contains(dev) || !dev.OutputStreams.Any())
                    return Maybe<string>.No("Epoch contains a stimulus for a device with no output stream: " + dev.Name);
            }

            foreach (var dev in epoch.Responses.Keys)
            {
                if (!Devices.Contains(dev) || !dev.InputStreams.Any()) 
                    return Maybe<string>.No("Epoch contains a response for a device with no input stream: " + dev.Name);
            }

            return Maybe<string>.Yes();
        }


        /// <summary>
        /// Begin a new Epoch Group (i.e. a logical block of Epochs). As each Epoch Group is persisted
        /// to a separate data file, this method creates the appropriate output file and
        /// EpochPersistor instance.
        /// </summary>
        /// <param name="path">The name of the file into which to store the epoch; if the name
        ///   ends in ".xml", it will store the file using the EpochXMLPersistor, and if the name
        ///   ends in ".hdf5", it will store the file using the EpochHDF5Persistor. This file will
        ///   be overwritten if it already exists at this location.</param>
        /// <param name="epochGroupLabel">Label for the new Epoch Group</param>
        /// <param name="source">Identifier for EpochGroup's Source</param>
        /// <param name="keywords"></param>
        /// <param name="properties"></param>
        /// <returns>The EpochPersistor instance to be used for saving Epochs</returns>
        /// <see cref="RunEpoch(Epoch, EpochPersistor)"/>
        public EpochPersistor BeginEpochGroup(string path, string epochGroupLabel, string source, IEnumerable<string> keywords, IDictionary<string, object> properties)
        {
            EpochPersistor result = null;
            if (path.EndsWith(".xml"))
            {
                result = new EpochXMLPersistor(path);
            }
            else if (path.EndsWith(".hdf5"))
            {
                result = new EpochHDF5Persistor(path, null);
            }
            else
                throw new ArgumentException(String.Format("{0} doesn't look like a legit Epoch filename", path));

            var kws = keywords == null ? new string[0] : keywords.ToArray();
            var props = properties ?? new Dictionary<string, object>();

            result.BeginEpochGroup(epochGroupLabel, source, kws, props, Guid.NewGuid(), DateTime.Now);

            return result;
        }

        /// <summary>
        /// Closes an Epoch Group. This method should be called after running all Epochs in the
        /// Epoch Group represented by EpochPersistor to give the persistor a chance to write any
        /// neceesary closing information.
        /// <para>
        /// Closes the persistor's file.
        /// </para>
        /// </summary>
        /// <param name="e">EpochPersistor representing the completed EpochGroup</param>
        /// <see cref="BeginEpochGroup"/>
        public void EndEpochGroup(EpochPersistor e)
        {
            e.EndEpochGroup();
            e.Close();
        }
        
        /// <summary>
        /// Matlab-friendly factory method to run a single Epoch.
        /// </summary>
        /// <remarks>Constructs an Epoch with homogenous stimulus ID, sample rate and units, then runs the
        /// constructed Epoch.
        /// </remarks>
        /// 
        /// <param name="protocolID">Protocol ID of the constructed Epoch</param>
        /// <param name="parameters">Protocol parameters of the constructed Epoch</param>
        /// <param name="stimulusID">Stimulus plugin ID for all constructed stimuli</param>
        /// <param name="stimulusSampleRate">Simulus sample rate for all constructed stimuli</param>
        /// <param name="stimuli">Simulus data for output devices</param>
        /// <param name="backgrounds">Backgrounds for output devices</param>
        /// <param name="responses">Devices from which to record Responses</param>
        /// <param name="persistor">EpochPersistor to persist Epoch</param>
        public void RunEpoch(
            string protocolID,
            IDictionary<string, object> parameters,
            string stimulusID,
            Measurement stimulusSampleRate,
            IDictionary<ExternalDeviceBase, IEnumerable<IMeasurement>> stimuli,
            IDictionary<ExternalDeviceBase, IMeasurement> backgrounds,
            IEnumerable<ExternalDeviceBase> responses,
            EpochPersistor persistor)
        {
            var epoch = new Epoch(protocolID,
                              parameters);
            foreach (var dev in stimuli.Keys)
            {
                var data = new OutputData(stimuli[dev],
                                          stimulusSampleRate,
                                          true);
                var stim = new RenderedStimulus(stimulusID,
                    (IDictionary<string, object>) new Dictionary<string, object> { { "data", data } },
                    (IOutputData) data);

                epoch.Stimuli[dev] = stim;
            }

            foreach (var dev in responses)
            {
                epoch.Responses[dev] = new Response();
            }

            foreach (var dev in backgrounds.Keys)
            {
                epoch.Backgrounds[dev] = new Background(backgrounds[dev], stimulusSampleRate);
            }

            RunEpoch(epoch, persistor);
        }

        /// <summary>
        /// Runs a single Epoch, bypassing the current Epoch queue. This method blocks until
        /// the Epoch is complete and the Controller is stopped. 
        /// 
        /// <para>The Controller cannot run more than one Epoch at a time. This method may only
        /// be used when the Controller is not running.</para>
        /// </summary>
        /// <param name="e">Single Epoch to present</param>
        /// <param name="persistor">EpochPersistor for saving the data. May be null to indicate epoch should not be persisted</param>
        /// <exception cref="ArgumentException">Validation failed for the provided Epoch</exception>
        /// <exception cref="ValidationException">Validation failed for this Controller</exception>
        /// <exception cref="SymphonyControllerException">This Controller is currently running</exception>
        public void RunEpoch(Epoch e, EpochPersistor persistor)
        {
            if (IsRunning)
                throw new SymphonyControllerException("Controller is currently running");

            if (!Validate())
                throw new ValidationException(Validate());

            if (!ValidateEpoch(e))
                throw new ArgumentException(ValidateEpoch(e));
            
            IsRunning = true;
            IsPauseRequested = false;
            IsStopRequested = false;

            OnStarted();
            
            EventHandler<TimeStampedEpochEventArgs> epochCompleted = (c, args) => RequestStop();

            try
            {
                CompletedEpoch += epochCompleted;

                var singleEpochQueue = new ConcurrentQueue<Epoch>(new[] { e });
                Process(singleEpochQueue, persistor);
            }
            finally
            {
                CompletedEpoch -= epochCompleted;
            }
        }
        
        /// <summary>
        /// Asynchronously starts processing the Epoch queue. The Controller will not stop until requested 
        /// with RequestPause() or RequestStop(), or a processing error occurs. In periods when the queue 
        /// is empty and there is no Epoch data remaining to process, a background stream will be presented
        /// for each device and no data will be recorded.
        ///
        /// <para>Epochs may be enqueued before and during processing of the Epoch queue.</para>
        /// </summary>
        /// <param name="persistor">EpochPersistor for saving the data. May be null to indicate epoch should not be persisted</param>
        /// <returns>Task processing the Epoch queue</returns>
        /// <exception cref="ValidationException">Validation failed for this Controller</exception>
        /// <exception cref="SymphonyControllerException">This Controller is currently running</exception>
        /// <see cref="BackgroundStreams"/>
        /// <see cref="RequestPause()"/>
        /// <see cref="RequestStop()"/>
        public Task StartAsync(EpochPersistor persistor)
        {
            if (IsRunning)
                throw new SymphonyControllerException("Controller is currently running");

            if (!Validate())
                throw new ValidationException(Validate());

            IsRunning = true;
            IsPauseRequested = false;
            IsStopRequested = false;

            OnStarted();

            return Task.Factory.StartNew(() => Process(EpochQueue, persistor), TaskCreationOptions.LongRunning);
        }

        /// <summary>
        /// Spins in a loop buffering Epochs from the given Epoch queue as required to satisfy PullOutputData
        /// requests from the output pipeline. When the queue is exhausted, the Controller's BackgroundStreams
        /// will be used to feed the pipeline, ensuring that the pipeline is never starved.
        /// </summary>
        /// <param name="epochQueue">Epoch queue to process</param>
        /// <param name="persistor">Epoch persistor for saving data</param>
        private void Process(ConcurrentQueue<Epoch> epochQueue, EpochPersistor persistor)
        {
            try
            {
                ProcessLoop(epochQueue, persistor);
            }
            finally
            {
                if (IsRunning)
                {
                    Stop();
                }
            }
        }

        private void Stop()
        {
            try
            {
                Task.WaitAll(PersistEpochTasks.ToArray());
            }
            catch (Exception ex)
            {
                log.ErrorFormat("An error occurred while saving Epochs: {0}", ex);
                throw new SymphonyControllerException("Unable to write Epoch data to persistor.", ex);
            }
            finally
            {
                IsRunning = false;
                OnStopped();
            }
        }

        private void ProcessLoop(ConcurrentQueue<Epoch> epochQueue, EpochPersistor persistor)
        {           
            var cts = new CancellationTokenSource();
            var cancellationToken = cts.Token;

            var incompleteEpochs = new ConcurrentQueue<Epoch>();
            
            EventHandler<TimeStampedEventArgs> stopRequested = (c, args) =>
                {
                    DAQController.RequestStop();
                };

            EventHandler<TimeStampedDeviceOutputStreamEventArgs> outputPulled = (c, args) =>
                {
                    var stream = args.Stream;

                    if (stream.IsAtEnd)
                    {
                        bool didBufferEpoch = false;

                        Epoch nextEpoch;
                        if (epochQueue.TryPeek(out nextEpoch))
                        {
                            bool shouldBufferEpoch = !nextEpoch.WaitForTrigger && !IsPauseRequested && !IsStopRequested;

                            if (shouldBufferEpoch && epochQueue.TryDequeue(out nextEpoch))
                            {
                                BufferEpoch(nextEpoch);
                                incompleteEpochs.Enqueue(nextEpoch);
                                didBufferEpoch = true;
                            }
                        }
                            
                        if (!didBufferEpoch)
                        {
                            BufferBackground();
                        }
                    }
                };

            EventHandler<TimeStampedDeviceInputStreamEventArgs> inputPushed = (c, args) =>
                {
                    Epoch currentEpoch;
                    if (!incompleteEpochs.TryPeek(out currentEpoch))
                        return;
                    
                    if (currentEpoch.IsComplete)
                    {
                        log.DebugFormat("Completed Epoch: {0}", currentEpoch.ProtocolID);

                        var completeTask = Task.Factory.StartNew(() => OnCompletedEpoch(currentEpoch),
                                                                 CancellationToken.None,
                                                                 TaskCreationOptions.None,
                                                                 CompletedEpochTaskScheduler);

                        CompletedEpochTasks = CompletedEpochTasks.Where(t => !t.IsCompleted).ToList();
                        CompletedEpochTasks.Add(completeTask);

                        if (persistor != null && currentEpoch.ShouldBePersisted)
                        {
                            var persistTask = Task.Factory.StartNew(() =>
                                {
                                    log.DebugFormat("Saving completed Epoch ({0})...", currentEpoch.StartTime);
                                    SaveEpoch(persistor, currentEpoch);
                                },
                                cancellationToken,
                                TaskCreationOptions.PreferFairness,
                                PersistEpochTaskScheduler)
                                .ContinueWith((t) =>
                                    {
                                        cancellationToken.ThrowIfCancellationRequested();

                                        if (t.IsFaulted &&
                                            t.Exception != null)
                                        {
                                            throw t.Exception;
                                        }
                                    },
                                    cancellationToken);

                            PersistEpochTasks = PersistEpochTasks.Where(t => !t.IsCompleted).ToList();
                            PersistEpochTasks.Add(persistTask);
                        }

                        Epoch completedEpoch;
                        if (!incompleteEpochs.TryDequeue(out completedEpoch) || completedEpoch != currentEpoch)
                            throw new SymphonyControllerException("Failed to dequeue completed epoch");

                        if (incompleteEpochs.IsEmpty)
                        {
                            DAQController.RequestStop();
                        }
                    }
                };

            EventHandler<TimeStampedEventArgs> daqStopped = (daq, args) =>
                {
                    DAQController.WaitForInputTasks();
                };

            EventHandler<TimeStampedExceptionEventArgs> daqExceptionalStop = (daq, args) =>
                {
                    log.Debug("DAQ Controller stopped due to an exception");
                    throw new SymphonyControllerException("DAQ Controller stopped due to an exception", args.Exception);
                };

            try
            {
                RequestedStop += stopRequested;
                PulledOutputData += outputPulled;
                PushedInputData += inputPushed;
                DAQController.Stopped += daqStopped;
                DAQController.ExceptionalStop += daqExceptionalStop;

                while (!IsPauseRequested && !IsStopRequested)
                {
                    Epoch epoch;
                    if (epochQueue.TryDequeue(out epoch))
                    {
                        InitIOStreams();

                        BufferEpoch(epoch);
                        incompleteEpochs.Enqueue(epoch);

                        DAQController.Start(epoch.WaitForTrigger);
                    }
                }
            }
            finally
            {
                RequestedStop -= stopRequested;
                PulledOutputData -= outputPulled;
                PushedInputData -= inputPushed;
                DAQController.Stopped -= daqStopped;
                DAQController.ExceptionalStop -= daqExceptionalStop;

                DAQController.WaitForInputTasks();

                while (incompleteEpochs.Any())
                {
                    Epoch discardedEpoch;
                    if (incompleteEpochs.TryDequeue(out discardedEpoch))
                    {
                        log.Debug("Discarding incomplete epoch");
                        OnDiscardedEpoch(discardedEpoch);
                    }
                }
            }
        }

        /// <summary>
        /// Output streams that the Controller uses to provide data for the output pipeline.
        /// </summary>
        private ConcurrentDictionary<IExternalDevice, SequenceOutputStream> OutputStreams { get; set; }

        /// <summary>
        /// Input streams that the Controller uses to consume data from the input pipeline.
        /// </summary>
        private ConcurrentDictionary<IExternalDevice, SequenceInputStream> InputStreams { get; set; }

        private void InitIOStreams()
        {
            OutputStreams.Clear();
            InputStreams.Clear();
            foreach (var device in Devices)
            {
                if (device.OutputStreams.Any())
                {
                    OutputStreams[device] = SequenceOutputStream.Synchronized(new SequenceOutputStream());
                }

                if (device.InputStreams.Any())
                {
                    InputStreams[device] = SequenceInputStream.Synchronized(new SequenceInputStream());
                }
            }
        }

        /// <summary>
        /// Background streams to present in the absence of Epoch streams. All devices with a DAQOutputStream in 
        /// the Controller must have an associated background stream of indefinite duration or the Controller will 
        /// fail to validate.
        /// </summary>
        public IDictionary<IExternalDevice, IOutputStream> BackgroundStreams { get; set; }

        private void BufferEpoch(Epoch epoch)
        {
            foreach (var kv in OutputStreams)
            {
                var stream = epoch.GetOutputStream(kv.Key, DAQController.ProcessInterval);
                kv.Value.Add(stream);
            }

            foreach (var kv in InputStreams)
            {
                var stream = epoch.GetInputStream(kv.Key) ?? new NullInputStream(epoch.Duration);
                kv.Value.Add(stream);
            }

            log.DebugFormat("Buffered epoch: {0}", epoch.ProtocolID);
        }

        private void BufferBackground()
        {
            foreach (var kv in OutputStreams)
            {
                kv.Value.Add(BackgroundStreams[kv.Key]);
            }

            foreach (var kv in InputStreams)
            {
                kv.Value.Add(new NullInputStream());
            }

            log.DebugFormat("Buffered background streams");
        }

        private static readonly ILog log = LogManager.GetLogger(typeof(Controller));

        private void SaveEpoch(EpochPersistor persistor, Epoch e)
        {
            persistor.Serialize(e);
            OnSavedEpoch(e);
        }

        /// <summary>
        /// Request this Controller complete all currently buffered Epochs and then pause. This 
        /// method does not block and the Controller will not pause immediately. Always wait for
        /// the Controller's Running flag or Stopped event to indicate when the Controller has 
        /// actually paused.
        /// </summary>
        public void RequestPause()
        {
            IsPauseRequested = true;
            OnRequestedPause();
        }

        private bool IsPauseRequested { get; set; }

        /// <summary>
        /// Request this Controller stop and discard all incomplete buffered Epochs. This method 
        /// does not block and the Controller will not stop immediately. Always wait for the 
        /// Controller's Running flag or Stopped event to indicate when the Controller has 
        /// actually stopped.
        /// </summary>
        public void RequestStop()
        {
            IsStopRequested = true;
            OnRequestedStop();
        }

        private bool IsStopRequested { get; set; }
        
        /// <summary>
        /// Inform this Controller that the output pipeline sent output data "to the wire".
        /// </summary>
        /// <param name="device">ExternalDevice that output the data</param>
        /// <param name="outputTime">Approximate time the data was sent to the wire</param>
        /// <param name="duration">Duration of the data block send to the wire</param>
        /// <param name="configuration">Pipeline node configuration(s) for the output pipeline that processed the outgoing data</param>
        public virtual void DidOutputData(IExternalDevice device, DateTimeOffset outputTime, TimeSpan duration, IEnumerable<IPipelineNodeConfiguration> configuration)
        {
            OutputStreams[device].DidOutputData(outputTime, duration, configuration);
        }
    }

    /// <summary>
    /// Exception indicating a Symphony.Core.Controller excpetion.
    /// </summary>
    public class SymphonyControllerException : SymphonyException
    {
        public SymphonyControllerException(string message)
            : base(message)
        {
        }

        public SymphonyControllerException(string message, Exception underlyingException)
            : base(message, underlyingException)
        {
        }
    }
}
